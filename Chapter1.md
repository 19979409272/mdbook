## 变量声明
- 使用类型后置语法，优点：  
    1. 便于语法分析，变量名：变量类型， 永远用let声明局部变量
    2. 引入类型自动推导，类型描述并非必不可少，如果可以通过上下文环境由编译器自动分析这个变量的类型，完全能省略该类型
    3. 模式解构（目前的了解）
    ```rust
        let mut x = 5; // mut x 是一个模式， 而不能把let mut视为一个组合
    ```

    > *Note：*        
    > 1.  immutable变量不可赋值    
    > 2. 变量必须初始化才能使用   
    > 3. 变量遮蔽

## static变量
- static
    > *Note：*    
    > 1. 生命周期
    > 2. unsafe
    > 3. 声明时初始化
    > 4. 编译期常量
    > 5. 不可类型推导

## 常量
- const
    > *Note:*     
    > 1. 大写
    > 2. 无类型推导
    > 3. 不一定分配内存（内联优化）
    > 4. 不具备类似let的模式匹配

## 整数类型
- 有符号/无符号
- 进制表示`（0x|0o|0b）`
- 下划线分割数字，不影响语义，可添加后缀表明类型   

    >*Note：*    
    >1. 无法分析整数具体类型，默认为i32
    >2. 整数溢出：
    >    - debug插入溢出检查，溢出，引发panic
    >    - release自动舍弃高位
    >    - 编译开关
    >    - 标准库函数（`checked_*->None、saturating_*->Max/Min of scope、wrapping_*->throw top bit`）
    >    - `std::num::Warpping< T >`

## 浮点类型
- **有点枯燥，日后再来**

## 复合数据类型

- tuple
    - 无类型名
    - 访问元素的方法（模式匹配+索引）

    >    *Note:*     
    >    1. 只有一个元素加一个逗号以区分表达式   
    >    2. 空元组（unit）占用0内存空间

- struct    
    - 有类型名
    - 内部成员有名字空间

    > *Note:* 
    >    1. 无类型推断
    >    2. 初始化语法类似json
    >    3. 局部变量名字和成员变量一致可简写初始化（同模式匹配）
    >    4. `..expr`语法糖：放置在初始化表达式最后，只能一个

- tuple struct
    - 有类型名， 无成员名（圆括号）

    > *Note*  
    > - 只含括一个元素（newtype idiom），创建一个新的类型，可以有不同的方法（代理？）， 而type alias只是一个别名

- enum 
    - 强调或的关系，成员中的一个
    - 内部成员有名字空间，::访问
    - **不是很懂，日后再来**
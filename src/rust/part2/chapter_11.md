# 借用和生命周期

## 生命周期
- 创建 `->` 销毁

## 借用
- 借用与移动：
  - 借用临时获得读或写的权限，原变量管理权不变
  - 移动获得对内存的管理权限，原变量失去管理权
- `&`：只读借用
- `&mut`：可读写借用
- 借用指针对比普通指针：
    - 内部数据一致
    - 告诉编译器，它对指向的这块内存区域没有所有权(编译阶段不能写内存，运行阶段只是一个普通指针)
- 要获取可变借用指针，变量本身需要可变
- mut修饰变量名：这个变量可以被重新绑定
- mut修饰借用指针：被指向的对象可以被修改
```rust
let mut var = 0;
{
    let p1 = &mut var; // p1指针不能被重新绑定，我们可以通过p1改变bar的值

    *p1 = 1;
}
{
    let temp = 2;
    let mut p2 = &var; // p2指针能被重新绑定，不能通过p2修改var的值

    p2 = &temp; // p2重新绑定到&temp（类型一致）
}
{
    let mut temp = 3;
    let mut p3 = &mut var; // p3本身能被重新绑定，能通过p3修改var的值

    *p3 = 3;
    p3 = &mut temp;
}

```

## 借用规则
1. 借用指针不能比被指向变量存在时间更长
2. &mut借用只能指向本身有mut修饰的变量
3. 任何借用存在的时候，被借用的变量本身处于“冻结”状态
4. 如果**只有**&借用，则可同时存在多个借用
5. 如果存在&mut借用，则只能存在一个
6. 如果同时有**其他的**&或&mut借用存在，则编译错误

- **借用**，只能临时拥有读或写权限，没有义务管理生命周期，所以借用指针生命周期不能大于原变量，否则就是悬空指针

## 生命周期标记
### 函数生命周期标记
- 泛型参数
- `<'a>`, `&'a`
- 包含关系：`'a : 'b`（lifetime a outlives lifetime b）
- 对与借用指针，`'a:'b`意味着`&'a`合法，`&'b`也一定合法（**对于同一内存空间的借用？**）
- `'static`：程序开始到结束
- 引用类型支持协变：将两个引用类型的生命周期都缩小到某个生命周期以内

### 类型生命周期标记
- 自定义类型成员含有生命周期标记，该类型也需要标记
- `impl<'t> Test<'t> {fn test<'a>(...){..}}`**不懂**
- where T: 'a：T的所有生命周期参数必须不小于'a
- where T: 'static：T中不包含任何指向短生命周期的借用指针（除'static以外的任何借用）

## 省略生命周期标记
- type inference
- lifetime elision rules：
  - 每个带生命周期的入参，每个都对应不同的生命周期参数
  - 如果只有一个入参带生命周期参数，这返回值被指定为这个参数
  - 如果多个入参带生命周期参数，但其中有&self、&mut self,返回值指定为这个参数
  - 以上都不满足，则不能自动补全
<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>study forever</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="rust/index.html"><strong aria-hidden="true">1.</strong> rust深入浅出</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/part1/index.html"><strong aria-hidden="true">1.1.</strong> 第一部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/part1/chapter_1.html"><strong aria-hidden="true">1.1.1.</strong> 变量和类型</a></li><li class="chapter-item expanded "><a href="rust/part1/chapter_2.html"><strong aria-hidden="true">1.1.2.</strong> 语句和表达式</a></li><li class="chapter-item expanded "><a href="rust/part1/chapter_3.html"><strong aria-hidden="true">1.1.3.</strong> 函数</a></li><li class="chapter-item expanded "><a href="rust/part1/chapter_4.html"><strong aria-hidden="true">1.1.4.</strong> trait</a></li><li class="chapter-item expanded "><a href="rust/part1/chapter_5.html"><strong aria-hidden="true">1.1.5.</strong> 数组和字符串</a></li><li class="chapter-item expanded "><a href="rust/part1/chapter_6.html"><strong aria-hidden="true">1.1.6.</strong> 模式解构</a></li><li class="chapter-item expanded "><a href="rust/part1/chapter_7.html"><strong aria-hidden="true">1.1.7.</strong> 深入类型系统</a></li><li class="chapter-item expanded "><a href="rust/part1/chapter_8.html"><strong aria-hidden="true">1.1.8.</strong> 宏</a></li></ol></li><li class="chapter-item expanded "><a href="rust/part2/index.html"><strong aria-hidden="true">1.2.</strong> 第二部分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/part2/chapter_9.html"><strong aria-hidden="true">1.2.1.</strong> 内存管理基础</a></li><li class="chapter-item expanded "><a href="rust/part2/chapter_10.html"><strong aria-hidden="true">1.2.2.</strong> 所有权和移动语义</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">study forever</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的编程风格。 Rust语言原本是Mozilla员工Graydon Hoare的私人计划，而Mozilla于2009年开始赞助这个计划，并且在2010年首次公开。</p>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<ul>
<li><a href="rust/./part1/chapter_1.html">变量和类型</a></li>
<li><a href="rust/./part1/chapter_2.html">语句和表达式</a></li>
<li><a href="rust/./part1/chapter_3.html">函数</a></li>
<li><a href="rust/./part1/chapter_4.html">trait</a></li>
<li><a href="rust/./part1/chapter_5.html">数组和字符串</a></li>
<li><a href="rust/./part1/chapter_6.html">模式解构</a></li>
<li><a href="rust/./part1/chapter_7.html">深入类型系统</a></li>
<li><a href="rust/./part1/chapter_8.html">宏</a></li>
</ul>
<h2 id="内存安全"><a class="header" href="#内存安全">内存安全</a></h2>
<ul>
<li><a href="rust/./part2/chapter_9.html">内存管理基础</a></li>
</ul>
<h1 id="第一部分"><a class="header" href="#第一部分">第一部分</a></h1>
<h2 id="基础知识-1"><a class="header" href="#基础知识-1">基础知识</a></h2>
<blockquote>
<p>主要语法</p>
</blockquote>
<ul>
<li><a href="rust/part1/chapter_1.html">变量和类型</a></li>
<li><a href="rust/part1/chapter_2.html">语句和表达式</a></li>
<li><a href="rust/part1/chapter_3.html">函数</a></li>
<li><a href="rust/part1/chapter_4.html">trait</a></li>
<li><a href="rust/part1/chapter_5.html">数组和字符串</a></li>
<li><a href="rust/part1/chapter_6.html">模式解构</a></li>
<li><a href="rust/part1/chapter_7.html">深入类型系统</a></li>
<li><a href="rust/part1/chapter_8.html">宏</a></li>
</ul>
<h1 id="变量和类型"><a class="header" href="#变量和类型">变量和类型</a></h1>
<h2 id="变量声明"><a class="header" href="#变量声明">变量声明</a></h2>
<ul>
<li>
<p>使用类型后置语法，优点：</p>
<ol>
<li>便于语法分析，变量名：变量类型， 永远用let声明局部变量</li>
<li>引入类型自动推导，类型描述并非必不可少，如果可以通过上下文环境由编译器自动分析这个变量的类型，完全能省略该类型</li>
<li>模式解构（目前的了解）</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut x = 5; // mut x 是一个模式， 而不能把let mut视为一个组合
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><em>Note：</em></p>
<ol>
<li>immutable变量不可赋值</li>
<li>变量必须初始化才能使用</li>
<li>变量遮蔽</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="static变量"><a class="header" href="#static变量">static变量</a></h2>
<ul>
<li>static
<blockquote>
<p><em>Note：</em></p>
<ol>
<li>生命周期</li>
<li>unsafe</li>
<li>声明时初始化</li>
<li>编译期常量</li>
<li>不可类型推导</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<ul>
<li>const
<blockquote>
<p><em>Note:</em></p>
<ol>
<li>大写</li>
<li>无类型推导</li>
<li>不一定分配内存（内联优化）</li>
<li>不具备类似let的模式匹配</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="整数类型"><a class="header" href="#整数类型">整数类型</a></h2>
<ul>
<li>
<p>有符号/无符号</p>
</li>
<li>
<p>进制表示<code>（0x|0o|0b）</code></p>
</li>
<li>
<p>下划线分割数字，不影响语义，可添加后缀表明类型</p>
<blockquote>
<p><em>Note：</em></p>
<ol>
<li>无法分析整数具体类型，默认为i32</li>
<li>整数溢出：
<ul>
<li>debug插入溢出检查，溢出，引发panic</li>
<li>release自动舍弃高位</li>
<li>编译开关</li>
<li>标准库函数（<code>checked_*-&gt;None、saturating_*-&gt;Max/Min of scope、wrapping_*-&gt;throw top bit</code>）</li>
<li><code>std::num::Warpping&lt; T &gt;</code></li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="浮点类型"><a class="header" href="#浮点类型">浮点类型</a></h2>
<ul>
<li><strong>有点枯燥，日后再来</strong></li>
</ul>
<h2 id="复合数据类型"><a class="header" href="#复合数据类型">复合数据类型</a></h2>
<ul>
<li>
<p>tuple</p>
<ul>
<li>无类型名</li>
<li>访问元素的方法（模式匹配+索引）</li>
</ul>
<blockquote>
<p><em>Note:</em></p>
<ol>
<li>只有一个元素加一个逗号以区分表达式</li>
<li>空元组（unit）占用0内存空间</li>
</ol>
</blockquote>
</li>
<li>
<p>struct</p>
<ul>
<li>有类型名</li>
<li>内部成员有名字空间</li>
</ul>
<blockquote>
<p><em>Note:</em> </p>
<ol>
<li>无类型推断</li>
<li>初始化语法类似json</li>
<li>局部变量名字和成员变量一致可简写初始化（同模式匹配）</li>
<li><code>..expr</code>语法糖：放置在初始化表达式最后，只能一个</li>
</ol>
</blockquote>
</li>
<li>
<p>tuple struct</p>
<ul>
<li>有类型名， 无成员名（圆括号）</li>
</ul>
<blockquote>
<p><em>Note</em></p>
<ul>
<li>只含括一个元素（newtype idiom），创建一个新的类型，可以有不同的方法（代理？）， 而type alias只是一个别名</li>
</ul>
</blockquote>
</li>
<li>
<p>enum </p>
<ul>
<li>强调或的关系，成员中的一个</li>
<li>内部成员有名字空间，::访问</li>
<li>上游依赖问题</li>
<li><strong>不是很懂，日后再来</strong></li>
</ul>
</li>
</ul>
<h1 id="表达式与语句"><a class="header" href="#表达式与语句">表达式与语句</a></h1>
<h2 id="语句"><a class="header" href="#语句">语句</a></h2>
<ul>
<li>;</li>
<li>不产生值（ :() ）</li>
<li>{语句} =&gt; 表达式</li>
</ul>
<h2 id="表达式"><a class="header" href="#表达式">表达式</a></h2>
<ul>
<li>不带;</li>
<li>左值，右值</li>
</ul>
<h3 id="运算表达式"><a class="header" href="#运算表达式">运算表达式</a></h3>
<ul>
<li>‘+ - * / %’</li>
<li>连续比较问题</li>
<li>位运算</li>
<li>逻辑运算
<ul>
<li>短路现象 （ 逻辑与 | 逻辑或 ）</li>
</ul>
</li>
</ul>
<h3 id="赋值表达式"><a class="header" href="#赋值表达式">赋值表达式</a></h3>
<ul>
<li>复制或移动问题（Chapter11）</li>
<li>类型：unit（空的tuple（））
<ul>
<li>=&gt; 不可连续赋值 </li>
<li>=&gt; 避免条件判断 == 写成 = ，条件表达式类型必须bool类型</li>
</ul>
</li>
<li>组合赋值表达式（+=等）
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>不支持 <code>++</code>及<code>--</code> 同 python</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="语句块表达式"><a class="header" href="#语句块表达式">语句块表达式</a></h3>
<ul>
<li>按照顺序执行语句块内语句，并返回最后一个表达式类型</li>
</ul>
<h3 id="if-else"><a class="header" href="#if-else">if-else</a></h3>
<ul>
<li>语句块必须有大括号</li>
<li>if condition不需要括号</li>
<li>if,else类型必须一致，else分支省略，默认其为()</li>
</ul>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<ul>
<li>无限死循环</li>
<li>生命周期标识符， ‘a:loop { break ‘a} 控制跳出层数</li>
<li>作为表达式，<code>break value; </code></li>
<li>发散类型</li>
</ul>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<ul>
<li>loop 与 while的区别</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x;
loop {x = 1; break;} //静态分析得出x=1必然在println！之前执行过
println!(&quot;{}&quot;, x); //可以通过编译

let x;
while true {x=1; break;} //while语句的执行条件跟表达式在运行阶段的值有关，因此不确定x是否初始化
println!(&quot;{}&quot;, x); //不能通过编译（use of possibly uninitialized variable）
<span class="boring">}
</span></code></pre></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<ul>
<li>其他语言的for-each</li>
<li><code>for i in container {}</code></li>
<li>利用迭代器遍历</li>
<li>支持自定义类型（迭代器，容器）</li>
</ul>
<h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<ul>
<li>fn</li>
<li>-&gt;返回类型</li>
<li>return可选</li>
<li>参数列表模式解构（Chapter6）</li>
<li>头等公民</li>
</ul>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>不写返回类型默认返回unit</li>
<li>可嵌套item =&gt; 避免污染命名空间</li>
<li>每个函数具有自己独特的类型（即使特征相同）</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// add1 add2 fn((i32, i32)) -&gt; i32
let mut func = add1;
func = add2;  //error

// func转为通用fn类型
// as 
let mut func = add1 as fn((i32, i32))-&gt;i32;
// 显示类型标记
let mut func : fn((i32, i32))-&gt;i32 = add1;
<span class="boring">}
</span></code></pre></pre>
<h2 id="发散函数"><a class="header" href="#发散函数">发散函数</a></h2>
<ul>
<li>panic!()及基于它的函数</li>
<li>发散类型（可以被转为任意类型）</li>
</ul>
<h2 id="main函数"><a class="header" href="#main函数">main函数</a></h2>
<ul>
<li>单独API处理传递参数及返回状态码</li>
</ul>
<h2 id="const-fn"><a class="header" href="#const-fn">const fn</a></h2>
<ul>
<li>编译期执行</li>
<li>编译期常量</li>
</ul>
<h2 id="函数递归调用"><a class="header" href="#函数递归调用">函数递归调用</a></h2>
<h1 id="trait"><a class="header" href="#trait">trait</a></h1>
<h2 id="成员方法"><a class="header" href="#成员方法">成员方法</a></h2>
<ul>
<li>self，变量名，当前这个，实现了该trait,的具体类型</li>
<li><code>instance.fn()</code></li>
<li>Self，类型名</li>
<li>self指定类型 </li>
<li>self : Self类型的各种包装</li>
<li><code>impl trait for type</code>（为具体类型&amp;type增加成员方法）</li>
<li><code>impl type</code> 匿名impl，实现类型的内在方法</li>
<li><code>impl trait for dyn trait</code>（self是一个trait object胖指针，为该指针类型增加成员方法）</li>
</ul>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>第一个参数名不是self，不能采用小数点语法</li>
</ul>
</blockquote>
<h2 id="静态方法"><a class="header" href="#静态方法">静态方法</a></h2>
<ul>
<li>第一个参数不是self</li>
<li>函数名重名导致自动deref出错的问题</li>
<li>不需要static关键字</li>
</ul>
<h2 id="扩展方法"><a class="header" href="#扩展方法">扩展方法</a></h2>
<ul>
<li>利用trait给其他类型扩展方法</li>
</ul>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li><code>trait | type</code> 至少一者与trait处于同一crate</li>
<li>匿名impl必须与type在同一crate</li>
<li>trait不能直接作为实例变量、参数、返回值（编译期大小不确定）</li>
</ul>
</blockquote>
<h2 id="trait约束和继承"><a class="header" href="#trait约束和继承">trait约束和继承</a></h2>
<ul>
<li>泛型约束：<code>&lt;T : TraitName&gt;</code>，要求泛型参数实现该trait</li>
<li>where子句</li>
<li><code>trait Derived : othTrait</code> &lt;==&gt; <code>trait Derived where Self : othTrait</code></li>
</ul>
<h2 id="derive"><a class="header" href="#derive">Derive</a></h2>
<ul>
<li>自动<code>impl trait</code></li>
<li><code>#[derive(traits...)]</code></li>
</ul>
<h2 id="trait别名"><a class="header" href="#trait别名">trait别名</a></h2>
<h2 id="常见trait"><a class="header" href="#常见trait">常见trait</a></h2>
<h3 id="display和debug"><a class="header" href="#display和debug">Display和Debug</a></h3>
<ul>
<li><code>{}: Display</code></li>
<li><code>{:?}, {:#?}: Debug</code></li>
</ul>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>Display不提供自动derive</li>
<li>Display如何格式化取决于自己</li>
<li>默认实现<code>std::string::ToString</code>，包含to_String()方法</li>
<li>Debug方便调试</li>
</ul>
</blockquote>
<h3 id="partialordord"><a class="header" href="#partialordord">PartialOrd/Ord</a></h3>
<p><strong>日后再说</strong></p>
<h3 id="sized"><a class="header" href="#sized">Sized</a></h3>
<ul>
<li>约束</li>
<li>编译器推导</li>
</ul>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<ul>
<li>相当于提供一个默认值</li>
</ul>
<h1 id="数组和字符串"><a class="header" href="#数组和字符串">数组和字符串</a></h1>
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<ul>
<li><code>[T ; n]</code></li>
<li>同类型数字互相赋值</li>
<li>入参复制mode</li>
</ul>
<h3 id="内置方法"><a class="header" href="#内置方法">内置方法</a></h3>
<ol>
<li>比较</li>
<li>遍历（数组切片）</li>
</ol>
<h3 id="多维数组"><a class="header" href="#多维数组">多维数组</a></h3>
<ul>
<li><code>[[T;m];n]</code></li>
</ul>
<h3 id="数组切片"><a class="header" href="#数组切片">数组切片</a></h3>
<ul>
<li><code>（借用）&amp;array-&gt;Slice</code>（数组切片：数组到指针的安全转换）</li>
<li><code>Slice: &amp;[T]</code>（指针）</li>
<li><strong>对数组没有所有权（不懂，搁置）</strong></li>
<li><code>size_of::&lt;&amp;[T;n]&gt;() = one point</code></li>
<li><code>size_of::&lt;&amp;[T]&gt;() = two point</code>（携带长度信息）</li>
</ul>
<h3 id="dst和胖指针"><a class="header" href="#dst和胖指针">DST和胖指针</a></h3>
<ul>
<li><code>fat pointer -&gt; DST</code></li>
<li><code>Dynamic Sized Type</code>：编译期无法确定占用空间</li>
<li><code>[T]:DST；str:DST</code></li>
<li><code>&amp;[T]:fat pointer -&gt; [T]；&amp;str: fat pointer -&gt; str</code></li>
<li><code>::size_of::&lt;DST&gt;() = undefined</code></li>
<li><code>::size_of::&lt;fat pointer&gt;() = defined</code></li>
</ul>
<p><em>Note：</em></p>
<ol>
<li>只能通过指针间接<em>创建和操作</em>DST</li>
<li>局部变量和函数参数必须在编译期知道其大小（未实现Sized约束）, 所以不能是DST</li>
<li>enum不能包含DST</li>
<li>struct只能最后一个元素为DST，此时struct就是一个DST</li>
<li>胖指针的设计，避免参数传递退化为裸指针，丢失长度信息的问题</li>
</ol>
<h3 id="range"><a class="header" href="#range">Range</a></h3>
<ul>
<li><code>begin..end</code> 语法糖，范围：<code>[)</code></li>
<li>实现了<code>Iterator trait</code></li>
<li>Range其他类型:
<ul>
<li>Rangefrom：<code>begin..</code></li>
<li>RangeTo：<code>..end</code></li>
<li>full range：<code>..</code> </li>
</ul>
</li>
<li><code>..=</code> 范围：’[]‘</li>
<li><strong>用来数组索引（部分切片）：</strong></li>
<li><code>arr[..] : [i32] //arr : [i32; n] but arr[..] : DST</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr : [i32; 5] = [1, 2, 3, 4, 5];
let fat_arr : &amp;[i32] = &amp;arr[..];  //fat_arr is fat pointer
let oth_fat_arr : &amp;[i32] = &amp;fat_arr[2..]; //Rangefrom &amp;fat_arr[2..] = &amp;&amp;[i32][2..]   
//&amp;(&amp;[i32]) auto deref -&gt; &amp;[i32 ; n] =&gt; &amp;[i32 ; n][2..] = &amp;[i32]

<span class="boring">}
</span></code></pre></pre>
<h3 id="边界检查"><a class="header" href="#边界检查">边界检查</a></h3>
<ul>
<li>运行期边界检查</li>
<li>trait:
<ul>
<li>索引写：<code>std::ops::Index trait</code></li>
<li>索引读：<code>std::ops::IndexMut trait</code></li>
</ul>
</li>
<li>usize作索引</li>
<li>不推荐大量使用索引（正常的索引op会执行一次边界检查，推荐使用迭代器方法）</li>
</ul>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<h3 id="str"><a class="header" href="#str">&amp;str</a></h3>
<ul>
<li><code>str : DST</code></li>
<li><code>&amp;str : fat pointer</code> 字符串切片</li>
<li>对于一块字符串区间的借用，对指向的<strong>内存空间</strong>没有所有权，无法扩大引用的范围</li>
<li>utf-8</li>
<li>不能使用O(1)复杂度的索引</li>
<li><code>s.chars().nth(n)</code></li>
<li><code>&amp;str =</code> 指向字符串头部片段的指针+长度</li>
</ul>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<ul>
<li>权力不同于&amp;str</li>
<li>可以扩大引用的范围</li>
<li>堆</li>
<li>内部实现类似：<code>std::Vec&lt;u8&gt;</code></li>
<li><code>impl Deref&lt;Target=str&gt; for String</code></li>
</ul>
<h1 id="模式解构"><a class="header" href="#模式解构">模式解构</a></h1>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<ul>
<li>let语句中，<code>=</code>左边的就是模式，右边是需要被解构的内容</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 构造，三个元素组合到一起
let tuple = (1_i32, false, 3f32);
// 相反，一个组合的数据结构，拆解，分成三个不同变量
// 模式整体是一个变量名，其中引入了三个变量，分别绑定tuple的三个成员，模式整体与被解构内容类型一致
let (head, center, tail) = tuple;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>构造和解构遵循类似的语法</li>
</ul>
<h2 id="match"><a class="header" href="#match">match`</a></h2>
<ul>
<li>exhaustive-完整的匹配</li>
<li><code>_</code></li>
<li>enum上游依赖问题</li>
<li><code>[non_exhaustive]</code></li>
</ul>
<h3 id="_"><a class="header" href="#_"><code>_</code></a></h3>
<ul>
<li>作用：
<ul>
<li>占位符，匹配到，但忽略</li>
<li><code>_</code>：忽略绑定，直接调用析构函数</li>
<li><code>let _y = x</code>：x的所有权转移至_y</li>
</ul>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>不能作为变量名使用</li>
<li>匹配一个元素</li>
<li><code>..</code>匹配单个|多个元素</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="match也是表达式"><a class="header" href="#match也是表达式">match也是表达式</a></h3>
<ul>
<li>match表达式（非<code>;</code>）</li>
<li>match每个分支是表达式</li>
<li>每个分支需要具备同样的类型（要么<code>{}</code>包括，要么逗号分隔</li>
<li>使用 <code>|</code> 匹配</li>
<li>使用范围作匹配条件</li>
</ul>
<h3 id="guards"><a class="header" href="#guards">Guards</a></h3>
<ul>
<li>匹配看守（match guards)</li>
<li><code>var: if condition =&gt; {code block} | expression,</code></li>
<li>不保证不同分支重叠问题</li>
</ul>
<h3 id="变量绑定"><a class="header" href="#变量绑定">变量绑定</a></h3>
<ul>
<li><code>new_var: @ pattern =&gt; {code block} | expression,</code></li>
<li>使用<code>|</code>需要保证每个<code>condition</code>绑定这个<code>new_var</code></li>
</ul>
<h3 id="ref和mut"><a class="header" href="#ref和mut">ref和mut</a></h3>
<ul>
<li>ref: 绑定被匹配对象的引用，避免所有权转移
<blockquote>
<p><em>Note：</em></p>
<ul>
<li><code>ref</code>是模式的一部分，只能出现在 <code>=</code> 左边</li>
<li><code>&amp;</code> 是借用运算符，是表达式的一部分，只能出现在 <code>=</code> 右边</li>
<li>检测类型
<ul>
<li><code>fn type_id(_: ()) {}</code>检测类型</li>
<li><code>std::intrinsics::type_name::&lt;T&gt;()</code>检测类型</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>mut：修饰的变量绑定有修改数据的能力</li>
<li>重新绑定：mut修饰的变量绑定可重新绑定到其他同类型的变量</li>
<li>“重新绑定”与”变量遮蔽”</li>
<li>&amp;mut型引用：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// mut x 的mut：代表变量x本身可变，因此能重新绑定（指针的指向能变化）
// &amp;mut i32：修饰的指针，代表这个指针对于指向的内存具有修改能力
let mut x: &amp;mut i32;
<span class="boring">}
</span></code></pre></pre>
<h2 id="if-let和while-let"><a class="header" href="#if-let和while-let">if-let和while-let</a></h2>
<ul>
<li>if - let ：<code>if let PATTERN = EXPRESSION { BODY } [else]</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Some(value) 与 x: Option&lt;i32&gt;的成员Some&lt;i32&gt;进行模式匹配
// 如果Option状态为None，则不执行if代码块[如果有else分支，则执行else分支]
// 避免了对None值进行操作
// 对于类型参数是指针类型非常有用
if let Some(value) = x {
    //对x内的值操作(value)
} else {
    println!(&quot;if分支不匹配&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>while - let</p>
</li>
<li>
<p><code>|</code></p>
</li>
<li>
<p>变量绑定</p>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>match一定要完整匹配</li>
<li>if-let只匹配指定分支</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="函数和闭包参数做模式解构"><a class="header" href="#函数和闭包参数做模式解构">函数和闭包参数做模式解构</a></h2>
<ul>
<li>函数接受一个结构体参数，可以直接对参数做模式解构</li>
</ul>
<h1 id="深入类型系统"><a class="header" href="#深入类型系统">深入类型系统</a></h1>
<h2 id="代数类型系统adt"><a class="header" href="#代数类型系统adt">代数类型系统（ADT）</a></h2>
<ul>
<li>”基数”（cardinality）：一个类型所有取值的可能性
<ul>
<li>Cardinality(unit) = 1 : ()</li>
<li>Cardinality(bool) = 2 : true false</li>
<li>Cardinality(i32)  = $2^{32}$</li>
</ul>
</li>
<li>“同构”：复合类型的内部类型相同，基数一样，它们携带的信息量一样</li>
<li><code>Cardinality(Option&lt;T&gt;) = Cardinality(T) + 1</code></li>
<li>类型类比代数的变量，类型间的组合类比代数的运算</li>
<li><code>空enum</code>: 0，<code>空struct</code> | <code>unit</code>: 1 </li>
<li><code>enum</code>：和，<code>struct</code>：积，<code>array</code>：乘方...</li>
</ul>
<h2 id="never-type"><a class="header" href="#never-type">Never Type</a></h2>
<ul>
<li><code>Cardinality(T) = 2^bits_of(T)</code></li>
<li><code>unit | 空struct</code> 类比1，所以<code>bits_of(()) = log(1) = 0</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//定义HashSet只是将HashMap的“value”指定为unit
pub struct HashSet&lt;T, s = RandomState&gt; {
    map: HashMap&lt;T, (), S&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Never Type的属性：
<ul>
<li><code>Cardinality(Never) = 0</code></li>
<li><code>bits_of(Nerver) = log(0) = -∞</code></li>
<li>可以被转换成任意类型</li>
<li>根本不可能返回 </li>
<li>运行时不可能存在</li>
<li>根本不可能执行</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// continue;语句指定为nerver
// 编译器判断如下：
// 1. else分支类型与if一致
// 2. 执行到else分支，根本不可能对x赋值，会进入下一次循环
// 3. 后面的代码不可能执行
// 一切都在类型系统得到统一
let x: i32 = if cond { 1 } else { continue; }   
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>!: never </li>
<li><code>diverging function -&gt; never</code> </li>
</ul>
<p><em>Note：</em></p>
<ul>
<li>完整的never type的意义：
<ol>
<li><strong>可以使得泛型代码兼容diverging function</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call_fn&lt;T, F: Fn(i32) -&gt; T&gt; (f: F, arg: i32) -&gt; T { f(arg) }
//不把!当成一个真正意义上的的类型，那么这句话就编译错误，因为只有类型才能替换类型参数
call_fn(std::process::exit, 0);
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li><strong>更好的死代码检查</strong> (<strong>看不懂</strong>)</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let t = std::thread::spawn(|| panic!(&quot;nope&quot;));
t.join().unwrap();
println!(&quot;hello);
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li><strong>可以用更好的方式表达“不可能出现的情况”</strong>
<ul>
<li><code>type Err = !</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="再谈option类型"><a class="header" href="#再谈option类型">再谈Option类型</a></h2>
<ul>
<li><strong>空指针问题</strong>：违背类型系统</li>
</ul>
<blockquote>
<p>Type is a classification identifying one of various types of data, that determines the possible values for that, the operations that can be done on values of that type, the meaning of the data, and the way values of that type can be stored.</p>
</blockquote>
<blockquote>
<p>null实际上是在类型系统上打开了一个缺口，引入了一个必须在运行期特殊处理的特殊“值”。它就像一个全局的、无类型的singleton变量一样，可以无处不在，可以随意与任意指针实现自动类型转换。它让编译器的类型检查在此处失去了意义</p>
</blockquote>
<ul>
<li>Rust利用ADT将空指针和非空指针区分，分别赋予不同的操作权限，禁止空指针的解引用：编译器和静态检查工具不可能知道一个变量在运行期的“值”，但是，如果一个null从一个“值”上升为一个“类型”，那么静态检查就能发挥作用。</li>
<li>Option<T>是可空类型<code>enum Option&lt;T&gt; { None, Some(T) }</code></li>
<li>无法直接调用T类型的成员函数
<ul>
<li>拆</li>
<li>成员函数</li>
</ul>
</li>
<li><strong>暂时略过</strong></li>
</ul>
<h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<h2 id="简介-macro"><a class="header" href="#简介-macro">简介 macro</a></h2>
<ul>
<li>“卫生宏（hygiene）”</li>
<li>调用语法与函数有明显区别</li>
<li>实现与外部调用处于不同命名空间，访问范围严格受限，通过参数传入，不能随意在宏内访问和改变外部代码</li>
</ul>
<h3 id="实现编译阶段检查"><a class="header" href="#实现编译阶段检查">实现编译阶段检查</a></h3>
<ul>
<li><strong>如果用普通函数实现这个功能，不可能实现这样的编译阶段错误检查</strong></li>
<li><strong>日后再来</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // invalid reference to argument '0' (no arguments given)
    println!(&quot;number1 {} number2 {}&quot;);
}
</code></pre></pre>
<ul>
<li>检查正则表达式的正确性</li>
</ul>
<h3 id="实现编译期计算"><a class="header" href="#实现编译期计算">实现编译期计算</a></h3>
<ul>
<li>某些场景，利用宏来完成编译期计算也是一种可行的选择</li>
<li><code>file!(), line!()</code></li>
</ul>
<h3 id="实现自动代码生成"><a class="header" href="#实现自动代码生成">实现自动代码生成</a></h3>
<blockquote>
<p>Don’t Repeat Yourself</p>
</blockquote>
<ul>
<li><code>add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64} //std::ops::Add trait</code></li>
</ul>
<h3 id="实现语法扩展"><a class="header" href="#实现语法扩展">实现语法扩展</a></h3>
<ul>
<li><code>let v = vec![1, 2, 3, 4, 5];</code></li>
<li>增加表达能力</li>
<li>自定义DSL</li>
</ul>
<h2 id="示范型宏"><a class="header" href="#示范型宏">示范型宏</a></h2>
<ul>
<li>方式：
<ol>
<li>macro_rules!宏</li>
<li>编译器扩展</li>
</ol>
</li>
<li><code>macro_rules!</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 要实现的语法
let counts = hashmap! ['A' =&gt; 0, 'C' =&gt; 0];
...
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>rustc -Z unstable-options --pretty=expanded file.rs</code></li>
</ul>
<h2 id="宏11"><a class="header" href="#宏11">宏1.1</a></h2>
<h1 id="第二部分"><a class="header" href="#第二部分">第二部分</a></h1>
<h2 id="内存安全-1"><a class="header" href="#内存安全-1">内存安全</a></h2>
<blockquote>
<p>不带自动内存回收（Garbage Collection）的内存安全是Rust语言最重要的创新，是与其他语言最主要的区别所在，是Rust语言设计的核心。<br />
Rust希望通过语言机制和编译器的功能，把程序员易犯错、不易检查的问题解决在编译期，避免运行时的内存错误。</p>
</blockquote>
<ul>
<li><a href="rust/part2/chapter_9.html">内存管理基础</a></li>
<li><a href="rust/part2/chapter_10.html">所有权和移动语义</a></li>
</ul>
<h1 id="内存管理基础"><a class="header" href="#内存管理基础">内存管理基础</a></h1>
<h2 id="堆和栈"><a class="header" href="#堆和栈">堆和栈</a></h2>
<ul>
<li>函数调用栈</li>
<li>堆：为动态分配预留的内存空间</li>
<li>每个线程都有一个栈，每个应用程序通常仅有一个堆</li>
</ul>
<p><em>Note：</em></p>
<ol>
<li>栈上局部变量退出作用域自动释放</li>
<li>堆上变量需要手动释放，无作用域</li>
<li>栈大小编译阶段可知</li>
<li>栈最大长度，栈溢出（stack overflow）</li>
<li>堆的空间一般更大，内存分配不足（out of memory）</li>
</ol>
<h2 id="段错误"><a class="header" href="#段错误">段错误</a></h2>
<ul>
<li>GC</li>
<li>规范</li>
</ul>
<h2 id="内存安全-2"><a class="header" href="#内存安全-2">内存安全</a></h2>
<ul>
<li>空指针</li>
<li>野指针：未初始化</li>
<li>悬空指针：释放后，继续使用</li>
<li>未初始化内存</li>
<li>非法释放：两次释放</li>
<li>缓冲区溢出</li>
<li>执行非法函数指针</li>
<li>数据竞争</li>
</ul>
<h1 id="所有权和移动语义"><a class="header" href="#所有权和移动语义">所有权和移动语义</a></h1>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<ul>
<li>每个值都由一个变量管理，这个变量就是这个值，这块内存的所有者</li>
<li>每个值在一个时间点只有一个管理者</li>
<li>变量作用域结束，变量及值将被销毁</li>
</ul>
<h2 id="移动语义"><a class="header" href="#移动语义">移动语义</a></h2>
<ul>
<li>一个变量把它拥有的值转移给另一个变量，称“所有权的转移</li>
<li>赋值、函数返回、函数调用</li>
<li>简单的memcpy</li>
<li><strong>所有类型的默认语义</strong></li>
<li>降低了语言复杂度，不可能执行用户自定义的代码，没有任何内存安全风险，满足异常安全</li>
</ul>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>“语义”只是规定了编译器接受什么样的代码，以及执行后的效果用怎样的思维模型去理解</li>
<li>编译器有权在不改变语义的情况下做任何有利于执行效率的优化</li>
</ul>
</blockquote>
<h2 id="赋值语义"><a class="header" href="#赋值语义">赋值语义</a></h2>
<ul>
<li>凡事实现<code>std::marker::Copy trait</code>的类型，都是copy语义</li>
<li>基本类型</li>
<li>为自定义类型实现<code>Copy trait</code></li>
<li><code>Copy inherit Clone</code></li>
<li>derive attribute <code>#[derive(Copy, Clone)]</code></li>
</ul>
<h2 id="box类型"><a class="header" href="#box类型">Box类型</a></h2>
<ul>
<li>拥有所有权的指针</li>
<li><code>Box::new(T(value: 1))</code>：装箱到heap</li>
<li>Rust要求使用前必须初始化，所以Box<T> / &amp;T / &amp;mut T一定指向某个对象</li>
<li><code>box</code>语法：<code>box T{value: 1};</code> 通用的装箱语法</li>
</ul>
<h2 id="clone-vs-copy"><a class="header" href="#clone-vs-copy">Clone Vs. Copy</a></h2>
<h3 id="copy的含义"><a class="header" href="#copy的含义">Copy的含义</a></h3>
<ul>
<li><code>std::marker</code>：特殊的trait（<strong>Copy、Send、Sized、Sync</strong>），</li>
<li>impl后给类型标记，影响编译器的静态检查以及代码生成</li>
</ul>
<h3 id="copy的实现条件"><a class="header" href="#copy的实现条件">Copy的实现条件</a></h3>
<blockquote>
<p>POD（Plain Old Data）：普通的与几十年前C兼容的，可以使用memcpy原始函数操作的类型</p>
</blockquote>
<ul>
<li>所有成员都实现Copy trait</li>
<li>POD,且没有自定义析构函数</li>
<li><code>impl Copy for</code>基本类型，共享借用指针&amp; </li>
<li><code>not impl Copy for</code> Box、Vec、可写借用指针、&amp;mut等</li>
</ul>
<blockquote>
<p><em>Note：</em></p>
<ul>
<li>Box String Vec等不能实现memcpy,都不属于POD</li>
</ul>
</blockquote>
<h3 id="clone的含义"><a class="header" href="#clone的含义">Clone的含义</a></h3>
<ul>
<li><code>std::clone::Clone</code></li>
<li>无前提条件</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone : Sized { ///////trait 不是实现Sized约束
    fn clone(&amp;self) -&gt; Self; //没有默认实现
   
   //默认实现clone_from取决于clone实现
    fn clone_from(&amp;mut self, source: &amp;Self) {
        *self = source.clone() 
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>基于语义的复制，具体作用取决于具体类型</li>
<li>Box类型则是”深复制”，拷贝的不是内存地址，Rc类型引用计数+1</li>
<li>如果实现了Copy（浅复制），则clone也应是与copy语义相容，memcpy</li>
</ul>
<h3 id="自动derive"><a class="header" href="#自动derive">自动derive</a></h3>
<ul>
<li>对于泛型参数，自动derive会自动添加一个T: Copy约束</li>
<li><code>impl Clone</code> 调用每个成员的clone()方法</li>
</ul>
<h2 id="析构函数"><a class="header" href="#析构函数">析构函数</a></h2>
<ul>
<li>在对象消亡之前由编译器自动调用（编译期间）</li>
<li>析构函数不仅可管理内存资源，还可以管理文件（关闭文件）、锁、socket等</li>
<li><code>impl std::ops::Drop</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="主动析构"><a class="header" href="#主动析构">主动析构</a></h3>
<ul>
<li>主动调用析构函数是非法的</li>
<li>提前终止生命周期应调用 <code>std::mem::drop</code> 函数</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
//move语义
pub fn drop&lt;T&gt; (_x : T) { }
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>变量遮蔽（遮蔽变量与被遮蔽变量是两个不同的变量）不会导致变量生命周期提前结束</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
println!(&quot;{:p}&quot;, &amp;x); //两者地址不同

let x = 1;
println!(&quot;{:p}&quot;, &amp;x)
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>_</code>忽略绑定，直接析构</li>
</ul>
<h3 id="drop-vs-copy"><a class="header" href="#drop-vs-copy">Drop VS. Copy</a></h3>
<ul>
<li>如果类型可以memcpy复制，且没有内存安全问题（无自定义析构函数），才允许<code>impl Copy</code></li>
<li><strong>带有析构函数的类型不可能是Copy</strong>（Copy实现浅复制，有内存安全问题 | 基本类型创建在栈上）</li>
<li></li>
</ul>
<h3 id="析构标记"><a class="header" href="#析构标记">析构标记</a></h3>
<ul>
<li>析构函数的具体调用时机还和运行时的情况相关，编译器会在每个路径上插入标记，来标记该对象的析构函数是否被调用</li>
<li>编译阶段确定生命周期，执行阶段根据情况调用</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
